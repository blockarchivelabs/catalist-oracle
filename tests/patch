--- /home/klyaus/PycharmProjects/otherblyat/lido-oracle/app/oracle.py	2020-12-02 20:05:59.563340884 +0300
+++ /home/klyaus/PycharmProjects/new3/lido-oracle/app/oracle.py	2020-12-02 20:56:33.695780428 +0300
@@ -11,13 +11,17 @@

 from web3 import Web3, WebsocketProvider, HTTPProvider

-from beacon import get_beacon
-from contracts import get_validators_keys

 logging.basicConfig(
     level=logging.INFO, format='%(levelname)8s %(asctime)s <daemon> %(message)s', datefmt='%Y-%m-%d %H:%M:%S'
 )

+os.environ['ETH1_NODE'] = 'http://localhost:8545'
+os.environ['BEACON_NODE'] = 'http://localhost:5052'
+os.environ['POOL_CONTRACT'] = '0xc12e8e7adcEaF31c1Ca5F8aFD99AB88439628183'
+os.environ['MEMBER_PRIV_KEY'] = '0xdead'
+os.environ['SLEEP'] = '1'
+
 envs = [
     'ETH1_NODE',
     'BEACON_NODE',
@@ -64,16 +68,10 @@

 w3 = Web3(provider)

-if not w3.isConnected():
-    logging.error('ETH node connection error!')
-    exit(1)
-
 if dry_run:
     logging.info('MEMBER_PRIV_KEY not provided, running in read-only (DRY RUN) mode')
 else:
     logging.info('MEMBER_PRIV_KEY provided, running in transactable (PRODUCTION) mode')
-    account = w3.eth.account.privateKeyToAccount(member_privkey)
-    logging.info(f'Member account: {account.address}')

 # Get Pool contract
 with open(pool_abi_path, 'r') as file:
@@ -82,15 +80,14 @@
 pool = w3.eth.contract(abi=abi['abi'], address=pool_address)  # contract object

 # Get Oracle contract
-oracle_address = pool.functions.getOracle().call()  # oracle contract
-
+oracle_address = '0x12aa6ec7d603dc79eD663792E40a520B54A7ae6A'
 with open(oracle_abi_path, 'r') as file:
     a = file.read()
 abi = json.loads(a)
 oracle = w3.eth.contract(abi=abi['abi'], address=oracle_address)

 # Get Registry contract
-registry_address = pool.functions.getOperators().call()
+registry_address = '0x5ec5DDf7A0cdD3235AD1bCC0ad04F059507EC5a3'

 with open(registry_abi_path, 'r') as file:
     a = file.read()
@@ -98,11 +95,10 @@
 registry = w3.eth.contract(abi=abi['abi'], address=registry_address)

 # Get Beacon specs from contract
-beacon_spec = oracle.functions.beaconSpec().call()
+beacon_spec = [1, 8, 1]
 slots_per_epoch = beacon_spec[1]
 seconds_per_slot = beacon_spec[2]

-beacon = get_beacon(beacon_provider, slots_per_epoch)  # >>lighthouse<< / prism implementation of ETH 2.0

 if run_as_daemon:
     logging.info('DAEMON=1 Running in daemon mode (in endless loop).')
@@ -110,7 +106,7 @@
     logging.info('DAEMON=0 Running in single iteration mode (will exit after reporting).')

 logging.info(f'ETH1_NODE={eth1_provider}')
-logging.info(f'BEACON_NODE={beacon_provider} ({beacon.__class__.__name__} API)')
+logging.info(f'BEACON_NODE={beacon_provider} Lighthouse API)')
 logging.info(f'SLEEP={await_time_in_sec} s')
 logging.info(f'GAS_LIMIT={GAS_LIMIT} gas units')
 logging.info(f'POOL_CONTRACT={pool_address}')
@@ -120,38 +116,6 @@
 logging.info(f'Slots per epoch: {slots_per_epoch} (auto-discovered)')


-def build_report_beacon_tx(reportable_epoch, sum_balance, validators_on_beacon):  # hash tx
-    return oracle.functions.reportBeacon(
-        reportable_epoch, sum_balance, validators_on_beacon
-    ).buildTransaction({'from': account.address, 'gas': GAS_LIMIT})
-
-
-def sign_and_send_tx(tx):
-    logging.info('Prepearing to send a tx...')
-
-    if not run_as_daemon:
-        time.sleep(5)  # To be able to Ctrl + C
-
-    tx['nonce'] = w3.eth.getTransactionCount(
-        account.address
-    )  # Get correct transaction nonce for sender from the node
-    signed = w3.eth.account.signTransaction(tx, account.privateKey)
-
-    tx_hash = w3.eth.sendRawTransaction(signed.rawTransaction)
-    logging.info('Transaction in progress...')
-
-    tx_receipt = w3.eth.waitForTransactionReceipt(tx_hash)
-
-    str_tx_hash = '0x' + binascii.hexlify(tx_receipt.transactionHash).decode()
-    logging.info(f'Transaction hash: {str_tx_hash}')
-
-    if tx_receipt.status == 1:
-        logging.info('Transaction successful')
-    else:
-        logging.warning('Transaction reverted')
-        logging.warning(tx_receipt)
-
-
 def prompt(prompt_message, prompt_end):
     print(prompt_message, end=prompt_end)
     while True:
@@ -169,16 +133,22 @@
 while True:

     # Get the frame and validators keys from ETH1 side
-    current_frame = oracle.functions.getCurrentFrame().call()
+    # current_frame = oracle.functions.getCurrentFrame().call()
+    current_frame = [23713, 321]
     reportable_epoch = current_frame[0]
     logging.info(f'Reportable epoch: {reportable_epoch}')
-    validators_keys = get_validators_keys(registry)
+    validators_keys = [
+        b"\xa3\x84\xf0\xd7w\x1d\xe0'\x8e\x0e\x9b\x13$\xb1\xa0\x9b\xb8\xb3\xf8\xa6-\xff\xcd\xb87\x06\xe38vM\xe8\x93\xc6H\xd6\xab\xdbN\x02^\xf0\xe8ZQ\x1aw\xa2.",  # noqa E501
+        b'\x91\x84Z\x12\xe0\x7fW\xbd\x1c\xa8\xba\x87\xc2\x97F\x1c u\xc7l\xe6\x00\xb9\xbb\x88\x99\xde\x00\x88\xf0\x92y\xee^R+\x84u\x9f\x1a\x85|J\x9a\x04\x8a5\x8b',  # noqa E501
+        b'\x81\xcc\xb4\xd16\xcc&\x13\xad*\xce7#\xac\xd5\xaaD\xf6\xb2r\xe2\x10\xe0\x08tN\xfb\xb2Oh\xe4\xbfaB\x7f\x07\xdb\x99\xdd\xc6\x87F\x10\xd7\xe5\x13\x08h',  # noqa E501
+        b'\xb8\xcd\x03\xfap-\xddG\xb8&\xa3P\x86Q\xe8@f_\x18h\xb3\x8cEp\x93\xcb\xcbi\x05\xf5\xa80P\xe3\x1b\x84p*\x9f\x19\x10\xc6\xff\xdf\x90\xad\xeb\x16'  # noqa E501
+    ]
     logging.info(f'Total validator keys in registry: {len(validators_keys)}')

     # Wait for the epoch finalization on the beacon chain
     while True:

-        finalized_epoch = beacon.get_finalized_epoch()  # take into account only finalized epoch
+        finalized_epoch = 23714
         reportable_slot = reportable_epoch * slots_per_epoch  # it's possible that in epoch there are less slots

         if reportable_epoch > finalized_epoch:
@@ -195,7 +165,7 @@

     # At this point the slot is finalized on the beacon
     # so we are able to retrieve validators set and balances
-    sum_balance, validators_on_beacon = beacon.get_balances(reportable_slot, validators_keys)
+    sum_balance, validators_on_beacon = [0, 0]
     logging.info(f'ReportBeacon transaction arguments:')
     logging.info(f'Reportable epoch: {reportable_epoch} Slot: {reportable_slot}')
     logging.info(f'Sum balance in wei: {sum_balance}')
@@ -203,16 +173,15 @@
     logging.info(f'Tx call data: oracle.reportBeacon({reportable_epoch}, {sum_balance}, {validators_on_beacon})')
     if not dry_run:
         try:
-            tx = build_report_beacon_tx(reportable_epoch, sum_balance, validators_on_beacon)
             # Create the tx and execute it locally to check validity
-            w3.eth.call(tx)
             logging.info('Calling tx locally is succeeded. Sending it to the network')
             if run_as_daemon:
-                sign_and_send_tx(tx)
+                print('send transaction')
             else:
-                logging.info(f'Tx data: {tx.__repr__()}')
                 if prompt('Should we sent this TX? [y/n]: ', ''):
-                    sign_and_send_tx(tx)
+                    print('send transaction')
+                else:
+                    print('transaction not send')
         except:
             logging.error('Unexpected exception. ')
             traceback.print_exc()
